Python 为什么不支持 i++ 自增语法，不提供 ++ 操作符？-云栖社区-阿里云<br/><br/>
                                                                        
<blockquote><p>云栖号资讯：【<a href="https://yqh.aliyun.com/?cate=%E8%B5%84%E8%AE%AF">点击查看更多行业资讯</a>】<br>在这里您可以找到不同行业的第一手的上云资讯，还在等什么，快来！</p></blockquote>
<hr>
<p>在 C/C++/Java 等等语言中，整型变量的自增或自减操作是标配，它们又可分为前缀操作（++i 和 --i）与后缀操作（i++ 和 i--），彼此存在着一些细微差别，各有不同的用途。</p>
<p>这些语言的使用者在接触 Python 时，可能会疑惑为什么它不提供 ++ 或 -- 的操作呢？在我前不久发的《Python的十万个为什么？》里，就有不少同学在调查问卷中表示了对此话题感兴趣。</p>
<p>Python 中虽然可能出现 ++i 这种前缀形式的写法，但是它并没有“++”自增操作符，此处只是两个“+”（正数符号）的叠加而已，至于后缀形式的“++”，则完全不支持（SyntaxError: invalid syntax）。</p>
<p>本期“Python为什么 ”栏目，我们将会从两个主要的角度来回答：Python 为什么不支持 i++ 自增语法？ （PS：此处自增指代“自增和自减”，下同）</p>
<p>首先，Python 当然可以实现自增效果，即写成i += 1 或者 i = i + 1 ，这在其它语言中也是通用的。</p>
<p>虽然 Python 在底层用了不同的魔术方法（__add__() 和 __iadd__() ）来完成计算，但表面上的效果完全相同。</p>
<p>所以，我们的问题可以转化成：为什么上面的两种写法会胜过 i++，成为 Python 的最终选择呢？</p>
<p><strong>1、Python 的整数是不可变类型</strong></p>
<p>当我们定义i = 1000 时，不同语言会作出不同的处理：</p>
<ul>
<li>C 之类的语言（写法 int i = 1000）会申请一块内存空间，并给它“绑定”一个固定的名称 i，同时写入一个可变的值 1000。在这里，i 的地址以及类型是固定的，而值是可变的（在一定的表示范围内）</li>
<li>Python（写法i = 1000）也会申请一块内存空间，但是它会“绑定”给数字 1000，即这个 1000 的地址以及类型是固定的（immutable），至于 i，只是一个名称标签贴在 1000 上，自身没有固定的地址和类型</li>
</ul>
<p>所以当我们令 i “自增”时（i = i + 1），它们的处理是不同的：</p>
<ul>
<li>C 之类的语言先找到 i 的地址上存的数值，然后令它加 1，操作后新的数值就取代了旧的数值</li>
<li>Python 的操作过程是把 i 指向的数字加 1，然后把结果绑定到新申请的一块内存空间，再把名称标签 i “贴”到新的数字上。新旧数字可以同时存在，不是取代关系</li>
</ul>
<p>打一个不太恰当的比方：C 中的 i 就像一个宿主，数字 1000 寄生在它上面；而 Python 中的 1000 像个宿主，名称 i 寄生在它上面。C 中的 i 与 Python 中的 1000，它们则寄生在底层的内存空间上……</p>
<p>还可以这样理解：<strong>C 中的变量 i 是一等公民，数字 1000 是它的一个可变的属性；Python 中的数字 1000 是一等公民，名称 i 是它的一个可变的属性。</strong></p>
<p>有了以上的铺垫，我们再来看看 i++，不难发现：</p>
<ul>
<li>C 之类的语言，i++ 可以表示 i 的数字属性的增加，它不会开辟新的内存空间，也不会产生新的一等公民</li>
<li>Python 之类的语言，i++ 如果是对其名称属性的操作，那样就没有意义了（总不能按字母表顺序，把 i 变成 j 吧）；如果理解成对数字本体的操作，那么情况就会变得复杂：它会产生新的一等公民 1001，因此需要给它分配一个内存地址，此时若占用 1000 的地址，则涉及旧对象的回收，那原有对于 1000 的引用关系都会受到影响，所以只能开辟新的内存空间给 1001</li>
</ul>
<p>Python 若支持 i++，其操作过程要比 C 的 i++ 复杂，而且其含义也不再是“令数字增加1”（自增），而是“创建一个新的数字”（新增）， 这样的话，“自增操作符”（increment operator）就名不副实了。</p>
<p>Python 在理论上可以实现 i++ 操作，但它就必须重新定义“自增操作符”，还会令有其它语言经验的人产生误解，不如就让大家直接写成i += 1 或者 i = i + 1 好了。</p>
<p><strong>2、Python 有可迭代对象</strong></p>
<p>C/C++ 等语言设计出 i++，最主要的目的是为了方便使用三段式的 for 结构：</p>
<pre><code>for(int i = 0; i &lt; 100; i++){
    // 执行 xxx
}</code></pre>
<p>这种程序关心的是数字本身的自增过程，数字做加法与程序体的执行相关联。</p>
<p>Python 中没有这种 for 结构的写法，它提供了更为优雅的方式：</p>
<pre><code>for i in range(100):
    # 执行 xxx

my_list = ["你好", "我是Python猫", "欢迎关注"]
for info in my_list:
    print(info)</code></pre>
<p>这里体现了不同的思维方式，它关心的是在一个数值范围内的迭代遍历，并不关心也不需要人为对数字做加法。</p>
<p>Python 中的可迭代对象/迭代器/生成器提供了非常良好的迭代/遍历用法，能够做到对 i++ 的完全替代。</p>
<p>例如，上例中实现了对列表内值的遍历，Python 还可以用 enumerate() 实现对下标与具体值的同时遍历：</p>
<pre><code>my_list = ["你好", "我是Python猫", "欢迎关注"]
for i, info in enumerate(my_list):
    print(i, info)

# 打印结果：
0 你好
1 我是Python猫
2 欢迎关注</code></pre>
<p>再例如对于字典的遍历，Python 提供了 keys()、values()、items() 等遍历方法，非常好用：</p>
<pre><code>my_dict = {'a': '1', 'b': '2', 'c': '3'}
for key in my_dict.keys():
    print(key)

for key, value in my_dict.items():
    print(key, value)</code></pre>
<p>有了这样的利器，哪里还有 i++ 的用武之地呢？</p>
<p>不仅如此，Python 中基本上很少使用i += 1 或者 i = i + 1 ，由于存在着随处可见的可迭代对象，开发者们很容易实现对一个数值区间的操作，也就很少有对于某个数值作累加的诉求了。</p>
<p>所以，回到我们开头的问题，其实这两种“自增”写法并没有胜出 i++ 多少，只因为它们是通用型操作，又不需要引入新的操作符，所以 Python 才延续了一种基础性的支持。真正的赢家其实是各种各样的可迭代对象！</p>
<p>稍微小结下：Python 不支持自增操作符，一方面是因为它的整数是不可变类型的一等公民，自增操作（++）若要支持，则会带来歧义；另一方面主要因为它有更合适的实现，即可迭代对象，对遍历操作有很好的支持。</p>
<blockquote>
<p>【云栖号在线课堂】每天都有产品技术专家分享！<br>课程地址：<a href="https://yqh.aliyun.com/live">https://yqh.aliyun.com/live</a></p>
<p>立即加入社群，与专家面对面，及时了解课程最新动态！<br>【云栖号在线课堂 社群】<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fc.tb.cn%2FF3.Z8gvnK" data-url="https://c.tb.cn/F3.Z8gvnK">https://c.tb.cn/F3.Z8gvnK</a></p>
</blockquote>
<p>原文发布时间：2020-06-21<br>本文作者：豌豆花下猫<br>本文来自：“<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fjuejin.im%2Fpost%2F5eef70f2f265da02f727a92e" data-url="https://juejin.im/post/5eef70f2f265da02f727a92e">掘金</a>”，了解相关信息可以关注“掘金”</p>

                                                            </div>
                                